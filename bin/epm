#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<USAGE
Extract Photos from Movie file, on a remote host.

Examples:
  epm "/data/videos/Photographer-Title_of_Video-[abc123].mkv"
  epm "/data/videos/sunset.mp4" step_time=1.0 border_px=10
  epm "/data/videos/sunset.mp4" output_dir=/data/photos update_immich=false
  epm "/data/videos/sunset.mp4" host=immich_lxc

Usage: epm "VIDEO" [output_dir=DIR] [options]

Arguments:
  VIDEO              Path to the video file on the remote host (positional).
                     Quote paths containing special characters (e.g. brackets).
  output_dir=DIR     Directory on the remote host to copy extracted photos into
                     (default: /mnt/nfs/photos/reference)

Options:
  host=NAME                Remote host to run on: immich_lxc (default) or media_vm
  step_time=SECONDS        Time between sampled frames (default: 0.5)
  border_px=INT            Border size in pixels around extracted photos (default: 5)
  min_photo_pct=INT        Minimum photo area as % of video frame area (default: 25)
  include_text=BOOL        Include text/annotations next to photos (default: false)
  update_immich=BOOL       Run Immich integration after extraction (default: true)
  help                     Show this help message

Environment variables (set on the remote host):
  IMMICH_API_KEY         Immich API key (required for Immich integration)
  IMMICH_LIBRARY_ID      Immich external library ID to scan
  IMMICH_API_URL         Immich server URL (e.g. http://localhost:2283)
  IMMICH_SHARE_USER      Immich username to share albums with (optional)
  PUSHOVER_USER_KEY      Pushover user key for notifications (optional)
  PUSHOVER_APP_TOKEN     Pushover application API token (optional)

Prerequisites:
  ssh media (for media_vm) or ssh immich (for immich_lxc) must be configured.
  The repo and dependencies are auto-installed on first run.
USAGE
}

# --- Local logging ---
# Resolve symlinks to find the actual script location (handles /usr/local/bin/epm -> repo/bin/epm)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
LOCAL_LOGS_DIR="$SCRIPT_DIR/../logs"
RUN_TIMESTAMP="$(date '+%Y-%m-%d_%H%M%S')"

copy_remote_log() {
    # Copy remote console log to local logs directory
    mkdir -p "$LOCAL_LOGS_DIR"
    local video_basename
    video_basename="$(basename "$VIDEO")"
    # Remove extension and sanitize for filename
    video_basename="${video_basename%.*}"
    video_basename="$(echo "$video_basename" | tr -cd '[:alnum:]_-')"
    local local_log="$LOCAL_LOGS_DIR/${RUN_TIMESTAMP}_${video_basename}.log"
    scp -q "$SSH_HOST:~/extract-photos/logs/$SESSION_NAME.log" "$local_log" 2>/dev/null || true
    if [ -f "$local_log" ]; then
        echo "Log saved to: $local_log"
    fi
}

read_remote_result() {
    local result
    result=$(ssh "$SSH_HOST" "cat /tmp/epm-result-$SESSION_NAME 2>/dev/null") || true
    if [ -n "$result" ]; then
        ssh "$SSH_HOST" "rm -f /tmp/epm-result-$SESSION_NAME" 2>/dev/null || true
    fi
    copy_remote_log
}

# --- Parse arguments ---
VIDEO=""
OUTPUT="/mnt/nfs/photos/reference"
UPDATE_IMMICH="true"
HOST_LABEL=""
EXTRA_ARGS=()

for arg in "$@"; do
  case "$arg" in
  help)
    usage
    exit 0
    ;;
  input_file=*)
    VIDEO="${arg#input_file=}"
    ;;
  output_dir=*)
    OUTPUT="${arg#output_dir=}"
    ;;
  host=*)
    HOST_LABEL="${arg#host=}"
    ;;
  step_time=*)
    EXTRA_ARGS+=("-s" "${arg#step_time=}")
    ;;
  border_px=*)
    EXTRA_ARGS+=("-b" "${arg#border_px=}")
    ;;
  min_photo_pct=*)
    EXTRA_ARGS+=("--min-photo-pct" "${arg#min_photo_pct=}")
    ;;
  include_text=*)
    val="${arg#include_text=}"
    if [ "$val" = "true" ]; then
      EXTRA_ARGS+=("--include-text")
    else
      EXTRA_ARGS+=("--no-include-text")
    fi
    ;;
  update_immich=*)
    UPDATE_IMMICH="${arg#update_immich=}"
    ;;
  *)
    # Bare positional arg (no = and no leading -) treated as input_file
    if [[ -z "$VIDEO" && "$arg" != *=* && "$arg" != -* ]]; then
      VIDEO="$arg"
    else
      echo "Error: unknown argument '$arg'" >&2
      usage >&2
      exit 1
    fi
    ;;
  esac
done

# Map host label to SSH host
HOST_LABEL="${HOST_LABEL:-immich_lxc}"
case "$HOST_LABEL" in
media_vm) SSH_HOST="media" ;;
immich_lxc) SSH_HOST="immich" ;;
*)
  echo "Error: unknown host '$HOST_LABEL' (expected media_vm or immich_lxc)" >&2
  exit 1
  ;;
esac

# Read input_file from stdin if piped and not provided as argument
if [[ -z "$VIDEO" ]] && ! [ -t 0 ]; then
  read -r VIDEO || true
  # Reattach stdin to /dev/null so later ssh -tt doesn't get a dead pipe
  exec </dev/null
fi

if [[ -z "$VIDEO" ]]; then
  echo "Error: input_file is required." >&2
  echo >&2
  usage >&2
  exit 1
fi

# --- Banner ---
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "ðŸ“¸ Extracting photos from video (on $HOST_LABEL)"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# --- Stable tmux session name (derived from video path) ---
SESSION_NAME="epm-$(printf '%s' "$VIDEO" | shasum | cut -c1-8)"

# --- Check for existing tmux session (reattach after disconnect) ---
if ssh "$SSH_HOST" "tmux has-session -t $SESSION_NAME 2>/dev/null"; then
    echo "Reattaching to running extraction..."
    ssh -tt "$SSH_HOST" "tmux attach-session -t $SESSION_NAME" </dev/tty
    read_remote_result
    exit 0
fi

# --- Auto-setup on remote ---
echo "Checking remote setup..."
ssh "$SSH_HOST" bash -l <<'SETUP'
set -euo pipefail
REPO_DIR="$HOME/extract-photos"
REPO_URL="https://github.com/johnmathews/extract-photos-from-videos.git"

# tmux is required for resilient remote execution
if ! command -v tmux &>/dev/null; then
    echo "Error: tmux is not installed on the remote machine." >&2
    echo "Install it with: sudo apt install tmux (Debian/Ubuntu)" >&2
    exit 1
fi

if [ ! -d "$REPO_DIR" ]; then
    echo "Setting up extract-photos on remote..."

    # Check prerequisites
    if ! command -v git &>/dev/null; then
        echo "Error: git is not installed on the remote machine." >&2
        exit 1
    fi

    # Install uv if not present
    if ! command -v uv &>/dev/null; then
        echo "Installing uv..."
        curl -LsSf https://astral.sh/uv/install.sh | sh
    fi

    echo "Cloning repository..."
    git clone "$REPO_URL" "$REPO_DIR"

    echo "Installing dependencies..."
    cd "$REPO_DIR"
    uv sync

    echo "Remote setup complete."
else
    echo "Updating remote repo..."
    cd "$REPO_DIR"
    git pull --ff-only
    uv sync --quiet
fi
SETUP

# --- Run extraction ---
echo "Extracting photos from: $VIDEO"
echo "Output directory: $OUTPUT"

# Upload the extraction script to a temp file on the remote, then execute it
# with -tt. This avoids the PTY-vs-heredoc conflict where -tt causes the
# heredoc to be interpreted interactively and child processes consume stdin.
REMOTE_SCRIPT="/tmp/epm-$$.sh"

ssh "$SSH_HOST" "cat > $REMOTE_SCRIPT" <<'EXTRACTION'
set -euo pipefail

VIDEO="$1"
OUTPUT="$2"
UPDATE_IMMICH="$3"
SESSION_NAME="$4"
shift 4

# Remaining args are extra flags for main.py
EXTRA=("$@")

RESULT_FILE="/tmp/epm-result-$SESSION_NAME"

write_result() {
    printf '%s\n%s\n%s\n' "$1" "$2" "$3" > "$RESULT_FILE"
}

# Clean up old console logs (>30 days)
find ~/extract-photos/logs -name "epm-*.log" -mtime +30 -delete 2>/dev/null || true

REPO_DIR="$HOME/extract-photos"

# Validate inputs
if [ ! -f "$VIDEO" ]; then
    echo "Error: video file not found: $VIDEO" >&2
    exit 1
fi

# Compute the sanitized output subdirectory name early so we can check for existing output
cd "$REPO_DIR"
source .venv/bin/activate
VIDEO_SUBDIR=$(python -c "
from extract_photos.utils import make_safe_folder_name
import os, sys
name = os.path.splitext(os.path.basename(sys.argv[1]))[0]
print(make_safe_folder_name(name))
" "$VIDEO")
FINAL_OUTPUT="$OUTPUT/$VIDEO_SUBDIR"

# Check for existing output (photos and/or video files)
HAS_JPG=false
HAS_VID=false
if [ -d "$FINAL_OUTPUT" ]; then
    for f in "$FINAL_OUTPUT"/*; do
        case "${f,,}" in
            *.jpg) HAS_JPG=true ;;
            *.mp4|*.mkv|*.avi|*.mov|*.webm) HAS_VID=true ;;
        esac
        $HAS_JPG && $HAS_VID && break
    done
fi

if $HAS_JPG && $HAS_VID; then
    echo "Output already exists: $FINAL_OUTPUT"
    read -p "(s)kip or (o)verwrite? [s/o]: " CHOICE
    case "$CHOICE" in
        o|O)
            echo "Removing old output..."
            rm -rf "$FINAL_OUTPUT"
            ;;
        *) echo "Skipping."; write_result 0 0 skipped; exit 0 ;;
    esac
elif $HAS_JPG; then
    echo "Incomplete output found (photos but no video): $FINAL_OUTPUT"
    read -p "(s)kip or (o)verwrite? [s/o]: " CHOICE
    case "$CHOICE" in
        o|O)
            echo "Removing old output..."
            rm -rf "$FINAL_OUTPUT"
            ;;
        *) echo "Skipping."; write_result 0 0 skipped; exit 0 ;;
    esac
fi

# Create temp directory with cleanup trap
TMPDIR="$(mktemp -d)"
trap 'write_result 1 0 interrupted; rm -rf "$TMPDIR"' EXIT

# Symlink the video into the temp directory
ln -s "$(realpath "$VIDEO")" "$TMPDIR/"

# Run the extraction tool (venv already activated above)
PYTHONUNBUFFERED=1 python -m extract_photos.main "$TMPDIR" "${EXTRA[@]+"${EXTRA[@]}"}"

# Find the video-specific output subdirectory (name is lowercased/sanitised by the tool)
EXTRACTED_BASE="$TMPDIR/extracted_photos"
EXTRACTED_DIR="$(find "$EXTRACTED_BASE" -mindepth 1 -maxdepth 1 -type d | head -1)"

if [ -z "$EXTRACTED_DIR" ] || [ ! -d "$EXTRACTED_DIR" ]; then
    echo "No photos extracted."
    write_result 0 0 no_photos
    exit 0
fi

PHOTO_COUNT="$(find "$EXTRACTED_DIR" -maxdepth 1 -type f | wc -l | tr -d ' ')"
if [ "$PHOTO_COUNT" -eq 0 ]; then
    echo "No photos extracted."
    write_result 0 0 no_photos
    exit 0
fi

# Copy extracted photos (files only, skip logs/ subdirectory) to
# FINAL_OUTPUT (computed earlier for the existing-output check).
mkdir -p "$FINAL_OUTPUT"
find "$EXTRACTED_DIR" -maxdepth 1 -type f -exec cp {} "$FINAL_OUTPUT/" \;
echo "Copied $PHOTO_COUNT photo(s) to $FINAL_OUTPUT"

# Copy or transcode the video alongside the photos (with progress bar)
REAL_VIDEO="$(realpath "$VIDEO")"
VIDEO_BASENAME=$(python -m extract_photos.transcode_playback "$REAL_VIDEO" "$FINAL_OUTPUT")

# Immich integration: scan library, create album, add assets, share
if [ "$OUTPUT" != "/mnt/nfs/photos/reference" ]; then
    echo "Skipping Immich integration (output is not /mnt/nfs/photos/reference)"
elif [ "$UPDATE_IMMICH" != "true" ]; then
    echo "Skipping Immich integration (update_immich=false)"
else
    MISSING_VARS=()
    [ -z "${IMMICH_API_KEY:-}" ] && MISSING_VARS+=(IMMICH_API_KEY)
    [ -z "${IMMICH_LIBRARY_ID:-}" ] && MISSING_VARS+=(IMMICH_LIBRARY_ID)
    [ -z "${IMMICH_API_URL:-}" ] && MISSING_VARS+=(IMMICH_API_URL)

    if [ ${#MISSING_VARS[@]} -gt 0 ]; then
        echo "Skipping Immich integration (missing env vars: ${MISSING_VARS[*]})"
    else
        IMMICH_ARGS=(
            --api-url "$IMMICH_API_URL"
            --api-key "$IMMICH_API_KEY"
            --library-id "$IMMICH_LIBRARY_ID"
            --asset-path "$FINAL_OUTPUT"
            --video-filename "$VIDEO_BASENAME"
        )
        [ -n "${IMMICH_SHARE_USER:-}" ] && IMMICH_ARGS+=(--share-user "$IMMICH_SHARE_USER")
        [ -n "${PUSHOVER_USER_KEY:-}" ] && [ -n "${PUSHOVER_APP_TOKEN:-}" ] && \
            IMMICH_ARGS+=(--pushover-user-key "$PUSHOVER_USER_KEY" --pushover-app-token "$PUSHOVER_APP_TOKEN")
        IMMICH_ARGS+=(--photo-count "$PHOTO_COUNT")

        python -m extract_photos.immich "${IMMICH_ARGS[@]}"
    fi
fi

# Copy console log alongside the extraction output (timestamped to preserve multiple runs)
if [ -f "$HOME/extract-photos/logs/$SESSION_NAME.log" ] && [ -d "${FINAL_OUTPUT:-}" ]; then
    mkdir -p "$FINAL_OUTPUT/logs"
    LOG_TIMESTAMP="$(date '+%Y-%m-%d_%H%M%S')"
    cp "$HOME/extract-photos/logs/$SESSION_NAME.log" "$FINAL_OUTPUT/logs/${LOG_TIMESTAMP}.txt" 2>/dev/null || true
fi

# Write success result (reset trap first to avoid writing "interrupted")
trap 'rm -rf "$TMPDIR"' EXIT
write_result 0 "$PHOTO_COUNT" success
EXTRACTION

# Start extraction inside a tmux session for resilience against SSH drops.
# If the connection is lost (e.g. laptop lid close), tmux keeps the process
# alive. Re-running the same epm command reattaches to the running session.
ssh "$SSH_HOST" "tmux new-session -d -s $SESSION_NAME \
    \"trap 'rm -f $REMOTE_SCRIPT' EXIT; bash -l $REMOTE_SCRIPT $(printf '%q ' "$VIDEO" "$OUTPUT" "$UPDATE_IMMICH" "$SESSION_NAME" "${EXTRA_ARGS[@]+"${EXTRA_ARGS[@]}"}"); stty sane; echo; echo 'Press Enter to close.'; read\""

# Capture all console output to a log file on the remote host
ssh "$SSH_HOST" "mkdir -p ~/extract-photos/logs && tmux pipe-pane -t $SESSION_NAME 'cat >> ~/extract-photos/logs/$SESSION_NAME.log'"

ssh -tt "$SSH_HOST" "tmux attach-session -t $SESSION_NAME" </dev/tty

read_remote_result
echo "Done."
